/**
 * @fileoverview Firestore Security Rules for CrewUp platform.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles,
 * allows public read access to opportunities with owner-only writes,
 * and manages team and chat message access based on team membership.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information, accessible only by the user themselves.
 * - /opportunities/{opportunityId}: Stores opportunity postings, publicly readable, but only editable by the author.
 * - /teams/{teamId}: Stores team information. Access controlled by team membership.
 * - /teams/{teamId}/messages/{messageId}: Stores chat messages for each team. Access controlled by team membership.
 *
 * Key Security Decisions:
 * - User profiles are private and only accessible by the owning user.
 * - Opportunities are publicly readable but only editable by the author.
 * - Team membership is managed via the `memberIds` array in the `Team` document.
 * - Listing opportunities is allowed for all users.
 *
 * Denormalization for Authorization:
 * - Opportunities contain an `authorId` field to easily check ownership for write operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profile data, allowing only the user to read and write their own profile.
     * @path /users/{userId}
     * @allow (create) - User with ID 'user123' creates their profile. request.auth.uid == 'user123' and request.resource.data.id == 'user123'.
     * @allow (get, update, delete) - User with ID 'user123' reads/updates/deletes their profile. request.auth.uid == 'user123'.
     * @deny (create) - User with ID 'user456' tries to create profile for 'user123'. request.auth.uid == 'user456', resource.data.id == 'user123'.
     * @deny (get, update, delete) - User with ID 'user456' tries to read/update/delete profile for 'user123'. request.auth.uid == 'user456'.
     * @principle Enforces document ownership for all operations on user profiles.
     */
    match /users/{userId} {
      // Allow the user to read their own profile
      allow get: if isSignedIn() && isOwner(userId);
      // Allow the user to list (but only for admin usage)
      allow list: if false; // Explicitly disallowing client-side listing

      // Allow the user to create their own profile if the ID matches their auth UID
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;

      // Allow the user to update their own profile, ensuring the user ID remains immutable
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;

      // Allow the user to delete their own profile
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages access to opportunity postings. Allows public read access, but restricts writes to the author.
     * @path /opportunities/{opportunityId}
     * @allow (get, list) - Any user can read/list opportunities.
     * @allow (create) - User with ID 'user123' creates an opportunity with authorId 'user123'. request.auth.uid == 'user123' && request.resource.data.authorId == 'user123'.
     * @allow (update, delete) - User with ID 'user123' updates/deletes an opportunity they authored (resource.data.authorId == 'user123').
     * @deny (create) - User with ID 'user456' tries to create an opportunity with authorId 'user123'. request.auth.uid == 'user456' && request.resource.data.authorId == 'user123'.
     * @deny (update, delete) - User with ID 'user456' tries to update/delete an opportunity authored by 'user123' (resource.data.authorId == 'user123').
     * @principle Allows public reads but enforces document ownership for writes.
     */
    match /opportunities/{opportunityId} {
      // Anyone can read or list opportunities
      allow get, list: if true;

      // Only the author can create an opportunity, and authorId must match their UID
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;

      // Only the author can update or delete an opportunity
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Controls access to team information. Allows members to read team data, and restricts creation/updates to team members.
     * @path /teams/{teamId}
     * @allow (get, list) - Any authenticated user that is a team member can read the team.
     * @allow (create) - Any authenticated user can create the team (but should later add members).
     * @allow (update, delete) - Only members of the team can update/delete the team.
     * @deny (get, list) - User with ID 'user456' tries to read team data without being a team member (resource.data.memberIds does not contain 'user456').
     * @principle Enforces team membership for access to team data.
     */
    match /teams/{teamId} {
      // Allow team members to read team information
      allow get, list: if isSignedIn() && isTeamMember(resource.data.memberIds);

      // Allow any signed-in user to create a team.
      allow create: if isSignedIn();

      // Allow team members to update and delete team information
      allow update: if isSignedIn() && isTeamMember(resource.data.memberIds);
      allow delete: if isSignedIn() && isTeamMember(resource.data.memberIds);
    }

    /**
     * @description Secures chat messages within a team.  Only team members can read/write messages.
     * @path /teams/{teamId}/messages/{messageId}
     * @allow (get, list) - User with ID 'user123' can read chat messages if they are a member of the team (teamId).
     * @allow (create) - User with ID 'user123' can create chat messages if they are a member of the team (teamId). request.auth.uid == request.resource.data.senderId.
     * @allow (update, delete) - User with ID 'user123' can update/delete messages if they are the sender and a member of the team.
     * @deny (get, list) - User with ID 'user456' tries to read chat messages without being a member of the team (teamId).
     * @deny (create) - User with ID 'user456' tries to create a chat message for team (teamId) without being a member. request.auth.uid == request.resource.data.senderId, but 'user456' not in team.
     * @principle Enforces team membership for access to chat messages.
     */
    match /teams/{teamId}/messages/{messageId} {
      // Allow team members to read and list chat messages
      allow get, list: if isSignedIn() && isTeamMember(get(/databases/$(database)/documents/teams/$(teamId)).data.memberIds);

      // Allow team members to create chat messages
      allow create: if isSignedIn() && isTeamMember(get(/databases/$(database)/documents/teams/$(teamId)).data.memberIds) && request.resource.data.senderId == request.auth.uid;

      // Allow the message sender to update or delete the message
      allow update: if isSignedIn() && isTeamMember(get(/databases/$(database)/documents/teams/$(teamId)).data.memberIds) && request.resource.data.senderId == resource.data.senderId;
      allow delete: if isSignedIn() && isTeamMember(get(/databases/$(database)/documents/teams/$(teamId)).data.memberIds) && resource.data.senderId == request.auth.uid;
    }

    // --- HELPER FUNCTIONS ---

    // Checks if the user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the user is the owner of the document
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Checks if the user is the owner of the document, and the document exists.
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    // Checks if the user is a member of the team
    function isTeamMember(memberIds) {
      return memberIds.hasAny([request.auth.uid]);
    }
  }
}