/**
 * @fileoverview Firestore Security Rules for CrewUp Platform
 *
 * Core Philosophy:
 * This ruleset enforces a mix of user-ownership and shared-access models. User profiles are strictly owned by the authenticated user.
 * Opportunities are publicly readable but writable only by the author. Teams are shared resources, accessible to team members.
 * Chat messages are accessible to members of the associated team.
 *
 * Data Structure:
 * - /users/{userId}: User profile data, owned by the user.
 * - /opportunities/{opportunityId}: Opportunity postings, publicly readable, owner-writable.
 * - /teams/{teamId}: Team data, accessible to team members.
 * - /teams/{teamId}/messages/{messageId}: Chat messages, accessible to team members.
 *
 * Key Security Decisions:
 * - User listing is disabled.
 * - Public read access is granted for the /opportunities collection.
 * - Strict ownership is enforced for user profiles under /users/{userId}.
 * - For shared resources like teams, authorization relies on a memberIds array.
 *
 * Denormalization for Authorization:
 * - The `Opportunity` documents store the `authorId`, which avoids the need to query UserProfile data for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the existing owner of the resource.
     * Ensures the document exists before authorizing.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user is a member of the team.
     */
    function isTeamMember(teamId) {
        return get(/databases/$(database)/documents/teams/$(teamId)).data.memberIds.hasAny([request.auth.uid]);
    }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *          request.auth.uid == 'user123' and request.resource.data.id == 'user123'
     * @allow (get) User with ID 'user123' can read their profile.
     *          request.auth.uid == 'user123'
     * @deny (update) User with ID 'user456' cannot update user 'user123' profile.
     *          request.auth.uid != 'user123'
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for opportunity postings.
     * @path /opportunities/{opportunityId}
     * @allow (get) Any user can read opportunity details.
     *          true
     * @allow (create) User with ID 'user123' can create an opportunity with authorId 'user123'.
     *          request.auth.uid == 'user123' and request.resource.data.authorId == 'user123'
     * @allow (update) User with ID 'user123' can update an opportunity they authored.
     *          request.auth.uid == 'user123' and resource.data.authorId == 'user123'
     * @deny (update) User with ID 'user456' cannot update an opportunity authored by 'user123'.
     *          request.auth.uid != 'user123'
     * @principle Enforces document ownership for writes, allows public read access.
     */
    match /opportunities/{opportunityId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.authorId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Rules for teams.
     * @path /teams/{teamId}
     * @allow (get) A team member can read team details.
     *          request.auth.uid is in resource.data.memberIds array
     * @allow (create) Any signed in user can create a team
     *          isSignedIn()
     * @allow (update) A team member can update team details.
     *          request.auth.uid is in resource.data.memberIds array
     * @deny (update) A non-team member cannot update team details.
     *          request.auth.uid is not in resource.data.memberIds array
     * @principle Enforces shared access based on team membership.
     */
    match /teams/{teamId} {
      allow get: if isSignedIn() && resource.data.memberIds.hasAny([request.auth.uid]);
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null && resource.data.memberIds.hasAny([request.auth.uid]);
      allow delete: if false;
    }

    /**
     * @description Rules for chat messages.
     * @path /teams/{teamId}/messages/{messageId}
     * @allow (get) A team member can read chat messages.
     *          request.auth.uid is in get(/databases/$(database)/documents/teams/$(teamId)).data.memberIds array
     * @allow (create) A team member can create a chat message.
     *          request.auth.uid is in get(/databases/$(database)/documents/teams/$(teamId)).data.memberIds array
     * @deny (update) No one should be able to update chat messages.
     *          false
     * @principle Enforces shared access based on team membership.
     */
    match /teams/{teamId}/messages/{messageId} {
      allow get: if isSignedIn() && isTeamMember(teamId);
      allow list: if isSignedIn() && isTeamMember(teamId);
      allow create: if isSignedIn() && isTeamMember(teamId);
      allow update: if false;
      allow delete: if false;
    }
  }
}