/**
 * @fileoverview Firestore Security Rules for CrewUp platform.
 *
 * Core Philosophy:
 * This ruleset enforces a combination of ownership-based and shared-access security models.
 * - User profiles are strictly private and accessible only to the owning user.
 * - Opportunities are publicly readable, but write access is restricted to the owner.
 * - Teams are secured using a shared-access model based on the 'memberIds' array.
 * - Chat messages inherit the team's shared-access permissions.
 *
 * Data Structure:
 * - /users/{userId}: User profile information, accessible only to the user.
 * - /opportunities/{opportunityId}: Opportunity postings, publicly readable, owner-only writes.
 * - /teams/{teamId}: Team information with a 'memberIds' array for shared access.
 * - /teams/{teamId}/messages/{messageId}: Chat messages for each team, inheriting team access.
 *
 * Key Security Decisions:
 * - User listing is denied to protect privacy.
 * - Public read access is enabled for opportunities to allow open browsing.
 * - Data validation is minimized for prototyping, focusing on ownership and relational integrity.
 *
 * Denormalization for Authorization:
 * - Opportunities have an `authorId` field to simplify owner-only write rules.
 * - Teams have a `memberIds` array to enable fast shared-access checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profile data, allowing only the owner to read and write.
     * @path /users/{userId}
     * @allow (create) - User with ID 'user123' can create their profile. (auth.uid == 'user123')
     * @allow (get, update, delete) - User with ID 'user123' can read/write their profile. (auth.uid == 'user123')
     * @deny (create, update, delete) - User with ID 'user456' cannot modify user 'user123's profile. (auth.uid != 'user123')
     * @deny (list) - No user can list all user profiles.
     * @principle Enforces strict document ownership for all operations on user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Secures opportunity postings, allowing public read access with owner-only writes.
     * @path /opportunities/{opportunityId}
     * @allow (get, list) - Any user (or no user) can read or list opportunities.
     * @allow (create) - User with ID 'user123' can create an opportunity with authorId 'user123'. (auth.uid == 'user123' and request.resource.data.authorId == 'user123')
     * @allow (update, delete) - User with ID 'user123' can update/delete their opportunity. (auth.uid == 'user123' and resource.data.authorId == 'user123')
     * @deny (create) - User with ID 'user123' cannot create an opportunity with authorId 'user456'. (request.resource.data.authorId != 'user123')
     * @deny (update, delete) - User with ID 'user456' cannot modify user 'user123's opportunity. (auth.uid != 'user123')
     * @principle Allows public read access while enforcing document ownership for writes.
     */
    match /opportunities/{opportunityId} {
      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.authorId == resource.data.authorId;
      allow delete: if isSignedIn() && request.resource.data.authorId == resource.data.authorId;
    }

    /**
     * @description Secures team information, allowing access to team members.
     * @path /teams/{teamId}
     * @allow (get, list) - Any team member can read or list the team.
     * @allow (create) - Only a signed in user can create a team. And the members list includes themselves
     * @allow (update, delete) - User with ID 'user123' can update/delete the team if they are a member.
     * @deny (create) - User with ID 'user123' cannot create a team with themself NOT in the memberIds.
     * @deny (update, delete) - User with ID 'user456' cannot modify the team if they are not a member.
     * @principle Enforces shared access based on team membership.
     */
    match /teams/{teamId} {
      function isTeamMember(teamId) {
        return request.auth.uid in resource.data.memberIds;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn() && resource.data.memberIds.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && request.resource.data.memberIds.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && resource.data.memberIds.hasAny([request.auth.uid]);
      allow delete: if isSignedIn() && resource.data.memberIds.hasAny([request.auth.uid]);
    }

    /**
     * @description Secures chat messages for each team, inheriting team access.
     * @path /teams/{teamId}/messages/{messageId}
     * @allow (get, list) - Any team member can read or list the messages
     * @allow (create) - Only a signed in user can create a message
     * @allow (update, delete) - No one can update or delete a message.
     * @principle Enforces shared access based on team membership.
     */
    match /teams/{teamId}/messages/{messageId} {
      function isTeamMember(teamId) {
        return request.auth.uid in get(/databases/$(database)/documents/teams/$(teamId)).data.memberIds;
      }

      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn() && isTeamMember(teamId);
      allow create: if isSignedIn() && isTeamMember(teamId);
      allow update, delete: if false;
    }
  }
}